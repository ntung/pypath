

<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pypath.share.common &mdash; pypath 0.10.6 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> pypath
          

          
          </a>

          
            
            
              <div class="version">
                0.10.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../webservice.html">Webservice</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Release history</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pypath</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pypath.share.common</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pypath.share.common</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1">#</span>
<span class="c1">#  This file is part of the `pypath` python module</span>
<span class="c1">#  Contains helper functions shared by different modules.</span>
<span class="c1">#</span>
<span class="c1">#  Copyright</span>
<span class="c1">#  2014-2020</span>
<span class="c1">#  EMBL, EMBL-EBI, Uniklinik RWTH Aachen, Heidelberg University</span>
<span class="c1">#</span>
<span class="c1">#  File author(s): Dénes Türei (turei.denes@gmail.com)</span>
<span class="c1">#                  Nicolàs Palacio</span>
<span class="c1">#                  Olga Ivanova</span>
<span class="c1">#</span>
<span class="c1">#  Distributed under the GPLv3 License.</span>
<span class="c1">#  See accompanying file LICENSE.txt or copy at</span>
<span class="c1">#      http://www.gnu.org/licenses/gpl-3.0.html</span>
<span class="c1">#</span>
<span class="c1">#  Website: http://pypath.omnipathdb.org/</span>
<span class="c1">#</span>

<span class="c1">#TODO requires cleaning, check what functions are not used and may be removed.</span>
<span class="c1">#Some parts can go to jsons.</span>

<span class="kn">from</span> <span class="nn">future.utils</span> <span class="k">import</span> <span class="n">iteritems</span>
<span class="kn">from</span> <span class="nn">past.builtins</span> <span class="k">import</span> <span class="n">xrange</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">reduce</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;ROOT&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aacodes&#39;</span><span class="p">,</span> <span class="s1">&#39;aaletters&#39;</span><span class="p">,</span>
    <span class="s1">&#39;simple_types&#39;</span><span class="p">,</span> <span class="s1">&#39;numeric_types&#39;</span><span class="p">,</span> <span class="s1">&#39;list_like&#39;</span><span class="p">,</span>
    <span class="s1">&#39;uniq_list&#39;</span><span class="p">,</span> <span class="s1">&#39;add_to_list&#39;</span><span class="p">,</span> <span class="s1">&#39;add_to_set&#39;</span><span class="p">,</span> <span class="s1">&#39;gen_session_id&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sorensen_index&#39;</span><span class="p">,</span> <span class="s1">&#39;simpson_index&#39;</span><span class="p">,</span> <span class="s1">&#39;simpson_index_counts&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span> <span class="s1">&#39;console&#39;</span><span class="p">,</span> <span class="s1">&#39;wcl&#39;</span><span class="p">,</span> <span class="s1">&#39;flat_list&#39;</span><span class="p">,</span> <span class="s1">&#39;char_types&#39;</span><span class="p">,</span>
    <span class="s1">&#39;del_empty&#39;</span><span class="p">,</span> <span class="s1">&#39;get_args&#39;</span><span class="p">,</span> <span class="s1">&#39;something&#39;</span><span class="p">,</span> <span class="s1">&#39;rotate&#39;</span><span class="p">,</span> <span class="s1">&#39;clean_dict&#39;</span><span class="p">,</span>
    <span class="s1">&#39;igraph_graphics_attrs&#39;</span><span class="p">,</span> <span class="s1">&#39;md5&#39;</span><span class="p">,</span> <span class="s1">&#39;mod_keywords&#39;</span><span class="p">,</span>
    <span class="s1">&#39;uniq_ord_list&#39;</span><span class="p">,</span> <span class="s1">&#39;dict_diff&#39;</span><span class="p">,</span> <span class="s1">&#39;to_set&#39;</span><span class="p">,</span> <span class="s1">&#39;to_list&#39;</span><span class="p">,</span>
    <span class="s1">&#39;unique_list&#39;</span><span class="p">,</span> <span class="s1">&#39;basestring&#39;</span><span class="p">,</span> <span class="s1">&#39;amino_acids&#39;</span><span class="p">,</span> <span class="s1">&#39;aminoa_1_to_3_letter&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aminoa_3_to_1_letter&#39;</span><span class="p">,</span> <span class="s1">&#39;pmod_bel&#39;</span><span class="p">,</span> <span class="s1">&#39;pmod_other_to_bel&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pmod_bel_to_other&#39;</span><span class="p">,</span> <span class="s1">&#39;refloat&#39;</span><span class="p">,</span> <span class="s1">&#39;reint&#39;</span><span class="p">,</span> <span class="s1">&#39;is_float&#39;</span><span class="p">,</span> <span class="s1">&#39;is_int&#39;</span><span class="p">,</span>
    <span class="s1">&#39;float_or_nan&#39;</span><span class="p">,</span> <span class="s1">&#39;non_digit&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># get the location</span>
<span class="n">ROOT</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
    <span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
    <span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">DATA</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ROOT</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="n">basestring</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">basestring</span> <span class="o">=</span> <span class="nb">str</span>

<span class="n">non_digit</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^\d.-]+&#39;</span><span class="p">)</span>


<span class="n">default_name_type</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;protein&quot;</span><span class="p">:</span> <span class="s2">&quot;uniprot&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;mirna&quot;</span><span class="p">:</span> <span class="s2">&quot;mirbase&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;lncrna&quot;</span><span class="p">:</span> <span class="s2">&quot;lncrnaname&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;drug&quot;</span><span class="p">:</span> <span class="s2">&quot;pubchem&quot;</span><span class="p">}</span>

<span class="n">aacodes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="s1">&#39;ALA&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="s1">&#39;GLY&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="s1">&#39;MET&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">:</span> <span class="s1">&#39;TRP&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="s1">&#39;TYR&#39;</span><span class="p">,</span>
           <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="s1">&#39;ARG&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="s1">&#39;CYS&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="s1">&#39;SER&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="s1">&#39;VAL&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="s1">&#39;ILE&#39;</span><span class="p">,</span>
           <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="s1">&#39;LEU&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="s1">&#39;PRO&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="s1">&#39;HIS&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="s1">&#39;THR&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="s1">&#39;GLU&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="s1">&#39;GLN&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="s1">&#39;GLX&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="s1">&#39;ASP&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="s1">&#39;ASN&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="s1">&#39;ASX&#39;</span><span class="p">,</span>
           <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="s1">&#39;LYS&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="s1">&#39;PHE&#39;</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">:</span> <span class="s1">&#39;XLE&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="s1">&#39;XAA&#39;</span><span class="p">}</span>

<span class="n">aanames</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;alanine&#39;</span><span class="p">:</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span>
           <span class="s1">&#39;arginine&#39;</span><span class="p">:</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span>
           <span class="s1">&#39;asparagine&#39;</span><span class="p">:</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span>
           <span class="s1">&#39;aspartic acid&#39;</span><span class="p">:</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span>
           <span class="s1">&#39;cysteine&#39;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span>
           <span class="s1">&#39;glutamine&#39;</span><span class="p">:</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span>
           <span class="s1">&#39;glutamic acid&#39;</span><span class="p">:</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span>
           <span class="s1">&#39;glycine&#39;</span><span class="p">:</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span>
           <span class="s1">&#39;histidine&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span>
           <span class="s1">&#39;isoleucine&#39;</span><span class="p">:</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span>
           <span class="s1">&#39;leucine&#39;</span><span class="p">:</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span>
           <span class="s1">&#39;lysine&#39;</span><span class="p">:</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span>
           <span class="s1">&#39;methionine&#39;</span><span class="p">:</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span>
           <span class="s1">&#39;phenylalanine&#39;</span><span class="p">:</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span>
           <span class="s1">&#39;proline&#39;</span><span class="p">:</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span>
           <span class="s1">&#39;serine&#39;</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">,</span>
           <span class="s1">&#39;threonine&#39;</span><span class="p">:</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span>
           <span class="s1">&#39;tryptophan&#39;</span><span class="p">:</span> <span class="s1">&#39;W&#39;</span><span class="p">,</span>
           <span class="s1">&#39;tyrosine&#39;</span><span class="p">:</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span>
           <span class="s1">&#39;valine&#39;</span><span class="p">:</span> <span class="s1">&#39;V&#39;</span><span class="p">}</span>

<span class="n">mod_keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Reactome&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;phosphopantetheinylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;phosphopantet&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;phosphorylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;phospho&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;acetylneuraminylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;acetylneuraminyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;acetylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;acetyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;farnesylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;farnesyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;palmitoylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;palmito&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;methylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;methyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;tetradecanoylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;tetradecanoyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;decanoylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;decanoyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;palmitoleylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;palmytoleil&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;formylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;formyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;ubiquitination&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ubiquitin&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;galactosylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;galactos&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;glutamylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;glutamyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;fucosylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;fucosyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;myristoylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;myristoyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;carboxylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;carboxyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;biotinylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;biotinyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;glycosylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;glycosyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;octanoylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;octanoyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;glycylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;glycyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;hydroxylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;hydroxy&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;sulfhydration&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;persulfid&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;thiolation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;thio&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;amidation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;amide&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;selenation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;seleno&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;glucosylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;glucosyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;neddylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;neddyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;sumoylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;sumoyl&#39;</span><span class="p">]),</span>
                             <span class="p">(</span><span class="s1">&#39;prenylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;prenyl&#39;</span><span class="p">])],</span>
                <span class="s1">&#39;ACSN&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;phosphorylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;phospho&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;glycylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;glycyl&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;ubiquitination&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ubiquitin&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;acetylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;acetyl&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;myristoylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;myristoyl&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;prenylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;prenyl&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;hydroxylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;hydroxy&#39;</span><span class="p">])],</span>
                <span class="s1">&#39;WikiPathways&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;NetPath&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;phosphorylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;phospho&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;glycylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;glycyl&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;ubiquitination&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ubiquitin&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;acetylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;acetyl&#39;</span><span class="p">])],</span>
                <span class="s1">&#39;PANTHER&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;phosphorylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;phospho&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;acetylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;acetyl&#39;</span><span class="p">])],</span>
                <span class="s1">&#39;NCI-PID&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;phosphorylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;phospho&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;methylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;methyl&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;farnesylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;farnesyl&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;palmitoylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;palmito&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;myristoylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;myristoyl&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;glycylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;glycyl&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;ubiquitination&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ubiquitin&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;acetylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;acetyl&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;glycosylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;glycosyl&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;geranylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;geranyl&#39;</span><span class="p">]),</span>
                            <span class="p">(</span><span class="s1">&#39;hydroxylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;hydroxy&#39;</span><span class="p">])],</span>
                <span class="s1">&#39;KEGG&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;phosphorylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;hospho&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;methylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;methyl&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;ubiquitination&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ubiquitin&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;acetylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;acetyl&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;hydroxylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;hydroxy&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;carboxyethylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;carboxyethyl&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;ribosylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ribosyl&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;nitrosylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;nitrosyl&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;sulfoylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ulfo&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;biotinylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;biotinyl&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;malonylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;malonyl&#39;</span><span class="p">]),</span>
                         <span class="p">(</span><span class="s1">&#39;glutarylation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;lutaryl&#39;</span><span class="p">])]}</span>


<span class="c1"># XXX: This is also in main.py, could be directly added in __all__?&#39;</span>
<span class="c1"># For compatibility with python 2, see https://docs.python.org/3/whatsnew/3.0.html</span>
<span class="k">if</span> <span class="s1">&#39;long&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">__builtins__</span><span class="p">):</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="k">if</span> <span class="s1">&#39;unicode&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">__builtins__</span><span class="p">):</span>
    <span class="n">unicode</span> <span class="o">=</span> <span class="nb">str</span>

<span class="c1"># Inverted `aacodes` dict</span>
<span class="n">aaletters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">aacodes</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">aacodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

<span class="c1"># Type definitions</span>
<span class="n">simple_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
<span class="n">numeric_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="n">char_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
<span class="n">list_like</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>


<span class="n">refloat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*-?\s*[\s\.\d]+\s*&#39;</span><span class="p">)</span>
<span class="n">reint</span>   <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*-?\s*[\s\d]+\s*&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="is_float"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.is_float">[docs]</a><span class="k">def</span> <span class="nf">is_float</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tells if a string represents a floating point number,</span>
<span class="sd">    i.e. it can be converted by `float`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">refloat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">num</span><span class="p">))</span></div>


<div class="viewcode-block" id="is_int"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.is_int">[docs]</a><span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tells if a string represents an integer,</span>
<span class="sd">    i.e. it can be converted by `int`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">reint</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">num</span><span class="p">))</span></div>


<div class="viewcode-block" id="float_or_nan"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.float_or_nan">[docs]</a><span class="k">def</span> <span class="nf">float_or_nan</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns `num` converted from string to float if `num` represents a</span>
<span class="sd">    float otherwise `numpy.nan`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


<div class="viewcode-block" id="to_set"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.to_set">[docs]</a><span class="k">def</span> <span class="nf">to_set</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes sure the object `var` is a set, if it is a list converts it to set,</span>
<span class="sd">    otherwise it creates a single element set out of it.</span>
<span class="sd">    If `var` is None returns empty set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
        
        <span class="k">return</span> <span class="n">var</span>
        
    <span class="k">elif</span> <span class="n">var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
        
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">basestring</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
        
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        
        <span class="k">return</span> <span class="p">{</span><span class="n">var</span><span class="p">}</span></div>


<div class="viewcode-block" id="to_list"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.to_list">[docs]</a><span class="k">def</span> <span class="nf">to_list</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes sure `var` is a list otherwise creates a single element list</span>
<span class="sd">    out of it. If `var` is None returns empty list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        
        <span class="k">return</span> <span class="n">var</span>
        
    <span class="k">elif</span> <span class="n">var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="k">return</span> <span class="p">[]</span>
        
    <span class="k">else</span><span class="p">:</span>
        
        <span class="k">return</span> <span class="p">[</span><span class="n">var</span><span class="p">]</span></div>


<span class="c1"># From http://www.peterbe.com/plog/uniqifiers-benchmark</span>
<div class="viewcode-block" id="unique_list"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.unique_list">[docs]</a><span class="k">def</span> <span class="nf">unique_list</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reduces a list to its unique elements.</span>

<span class="sd">    Takes any iterable and returns a list of unique elements on it. If</span>
<span class="sd">    the argument is a dictionary, returns a list of unique keys.</span>
<span class="sd">    **NOTE:** Does not preserve the order of the elements.</span>

<span class="sd">    :arg list seq:</span>
<span class="sd">        Sequence to be processed, can be any iterable type.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*list*) -- List of unique elements in the sequence *seq*.</span>

<span class="sd">    **Examples:**</span>
<span class="sd">        &gt;&gt;&gt; uniq_list(&#39;aba&#39;)</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">        &gt;&gt;&gt; uniq_list([0, 1, 2, 1, 0])</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">({}</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<span class="c1"># old ugly name</span>
<span class="n">uniq_list</span> <span class="o">=</span> <span class="n">unique_list</span>


<span class="k">def</span> <span class="nf">uniq_list1</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span> <span class="c1"># XXX: Not used</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Not order preserving</span>
<span class="sd">    From http://www.peterbe.com/plog/uniqifiers-benchmark</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">uniq_list2</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span> <span class="c1"># XXX: Not used</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Not order preserving</span>
<span class="sd">    From http://www.peterbe.com/plog/uniqifiers-benchmark</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">keys</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
        <span class="n">keys</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>


<div class="viewcode-block" id="flat_list"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.flat_list">[docs]</a><span class="k">def</span> <span class="nf">flat_list</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Coerces the elements of a list of iterables into a single list.</span>

<span class="sd">    :arg lsit lst:</span>
<span class="sd">        List to be flattened. Its elements can be also lists or any</span>
<span class="sd">        other iterable.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*list*) -- Flattened list of *lst*.</span>

<span class="sd">    **Examples:**</span>
<span class="sd">        &gt;&gt;&gt; flat_list([(0, 1), (1, 1), (2, 1)])</span>
<span class="sd">        [0, 1, 1, 1, 2, 1]</span>
<span class="sd">        &gt;&gt; flat_list([&#39;abc&#39;, &#39;def&#39;])</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">it</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">lst</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">sl</span><span class="p">]</span></div>


<div class="viewcode-block" id="del_empty"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.del_empty">[docs]</a><span class="k">def</span> <span class="nf">del_empty</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span> <span class="c1"># XXX: Only used in main.py line: 1278</span>
    <span class="sd">&quot;&quot;&quot;Removes empty entries of a list.</span>

<span class="sd">    It is assumed that elemenst of *lst* are iterables (e.g. [str] or</span>
<span class="sd">    [list]).</span>

<span class="sd">    :arg list lst:</span>
<span class="sd">        List from which empty elements will be removed.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*list*) -- Copy of *lst* without elements whose length was</span>
<span class="sd">        zero.</span>

<span class="sd">    **Example:**</span>
<span class="sd">        &gt;&gt;&gt; del_empty([&#39;a&#39;, &#39;&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lst</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))]</span></div>


<span class="c1"># Order preserving</span>
<span class="c1"># From http://www.peterbe.com/plog/uniqifiers-benchmark</span>
<div class="viewcode-block" id="uniq_ord_list"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.uniq_ord_list">[docs]</a><span class="k">def</span> <span class="nf">uniq_ord_list</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">idfun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># XXX: Only used in plot.py line: 510</span>
    <span class="sd">&quot;&quot;&quot;Reduces a list to its unique elements keeping their order.</span>

<span class="sd">    Returns a copy of *seq* without repeated elements. Preserves the</span>
<span class="sd">    order. If any element is repeated, the first instance is kept.</span>

<span class="sd">    :arg list seq:</span>
<span class="sd">        Or any other iterable type. The sequence from which repeated</span>
<span class="sd">        elements are to be removed.</span>
<span class="sd">    :arg function idfun:</span>
<span class="sd">        Optional, ``None`` by default. Identifier function, for each</span>
<span class="sd">        entry of *seq*, returns a identifier of that entry from which</span>
<span class="sd">        uniqueness is determined. Default behavior is f(x) = x. See</span>
<span class="sd">        examples below.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*list*) -- Copy of *seq* without the repeated elements</span>
<span class="sd">        (according to *idfun*).</span>

<span class="sd">    **Examples:**</span>
<span class="sd">        &gt;&gt;&gt; uniq_ord_list([0, 1, 2, 1, 5])</span>
<span class="sd">        [0, 1, 2, 5]</span>
<span class="sd">        &gt;&gt;&gt; uniq_ord_list(&#39;abracadabra&#39;)</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;, &#39;r&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="sd">        &gt;&gt;&gt; def f(x):</span>
<span class="sd">        ...     if x &gt; 0:</span>
<span class="sd">        ...             return 0</span>
<span class="sd">        ...     else:</span>
<span class="sd">        ...             return 1</span>
<span class="sd">        &gt;&gt;&gt; uniq_ord_list([-32, -42, 1, 15, -12], idfun=f)</span>
<span class="sd">        [-32, 1]</span>
<span class="sd">        &gt;&gt;&gt; def g(x): # Given a file name, return it without extension</span>
<span class="sd">        ...    return x.split(&#39;.&#39;)[0]</span>
<span class="sd">        &gt;&gt;&gt; uniq_ord_list([&#39;a.png&#39;, &#39;a.txt&#39;, &#39;b.pdf&#39;], idfun=g)</span>
<span class="sd">        [&#39;a.png&#39;, &#39;b.pdf&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">idfun</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">idfun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span>

    <span class="n">seen</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
        <span class="n">marker</span> <span class="o">=</span> <span class="n">idfun</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">marker</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">seen</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="add_to_list"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.add_to_list">[docs]</a><span class="k">def</span> <span class="nf">add_to_list</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">toadd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Adds elements to a list.</span>

<span class="sd">    Appends *toadd* to *lst*. Function differs from</span>
<span class="sd">    :py:func:`list.append` since is capable to handle different data</span>
<span class="sd">    types. This is, if *lst* is not a list, it will be converted to one.</span>
<span class="sd">    Similarly, if *toadd* is not a list, it will be converted and added.</span>
<span class="sd">    If *toadd* is or contains ``None``, these will be ommited. The</span>
<span class="sd">    returned list will only contain unique elements and does not</span>
<span class="sd">    necessarily preserve order.</span>

<span class="sd">    :arg list lst:</span>
<span class="sd">        List or any other type (will be converted into a list). Original</span>
<span class="sd">        sequence to which *toadd* will be appended.</span>
<span class="sd">    :arg any toadd:</span>
<span class="sd">        Element(s) to be added into *lst*.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*list*) -- Contains the unique element(s) from the union of</span>
<span class="sd">        *lst* and *toadd*. **NOTE:** Makes use of</span>
<span class="sd">        :py:func:`common.uniq_list`, does not preserve order of elements.</span>

<span class="sd">    **Examples:**</span>
<span class="sd">        &gt;&gt;&gt; add_to_list(&#39;ab&#39;, &#39;cd&#39;)</span>
<span class="sd">        [&#39;ab&#39;, &#39;cd&#39;]</span>
<span class="sd">        &gt;&gt;&gt; add_to_list(&#39;ab&#39;, [&#39;cd&#39;, None, &#39;ab&#39;, &#39;ef&#39;])</span>
<span class="sd">        [&#39;ab&#39;, &#39;ef&#39;, &#39;cd&#39;]</span>
<span class="sd">        &gt;&gt;&gt; add_to_list((0, 1, 2), 4)</span>
<span class="sd">        [0, 1, 2, 4]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="ow">in</span> <span class="n">simple_types</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">lst</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">toadd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lst</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">toadd</span><span class="p">)</span> <span class="ow">in</span> <span class="n">simple_types</span><span class="p">:</span>
        <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">toadd</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">toadd</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">toadd</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">toadd</span><span class="p">)</span>

        <span class="n">lst</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">toadd</span><span class="p">)</span>

    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
        <span class="n">lst</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">uniq_list</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span></div>


<div class="viewcode-block" id="add_to_set"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.add_to_set">[docs]</a><span class="k">def</span> <span class="nf">add_to_set</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">toadd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds elements to a set.</span>

<span class="sd">    Appends *toadd* to *st*. Function is capable to handle different</span>
<span class="sd">    input data types. This is, if *toadd* is a list, it will be</span>
<span class="sd">    converted to a set and added.</span>

<span class="sd">    :arg set st:</span>
<span class="sd">        Original set to which *toadd* will be added.</span>
<span class="sd">    :arg any toadd:</span>
<span class="sd">        Element(s) to be added into *st*.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*set*) -- Contains the element(s) from the union of *st* and</span>
<span class="sd">        *toadd*.</span>

<span class="sd">    **Examples:**</span>
<span class="sd">        &gt;&gt;&gt; st = set([0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; add_to_set(st, 3)</span>
<span class="sd">        set([0, 1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; add_to_set(st, [4, 2, 5])</span>
<span class="sd">        set([0, 1, 2, 4, 5])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">toadd</span><span class="p">)</span> <span class="ow">in</span> <span class="n">simple_types</span><span class="p">:</span>
        <span class="n">st</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">toadd</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">toadd</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">toadd</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">toadd</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">toadd</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">set</span><span class="p">:</span>
        <span class="n">st</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">toadd</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">st</span></div>


<div class="viewcode-block" id="something"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.something">[docs]</a><span class="k">def</span> <span class="nf">something</span><span class="p">(</span><span class="n">anything</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks if argument is empty.</span>

<span class="sd">    Checks if *anything* is empty or ``None``.</span>

<span class="sd">    :arg any anything:</span>
<span class="sd">        Self-explanatory.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*bool*) -- ``False`` if *anyhting* is ``None`` or any empty</span>
<span class="sd">        data type.</span>

<span class="sd">    **Examples:**</span>
<span class="sd">        &gt;&gt;&gt; something(None)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; something(123)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; something(&#39;Hello world!&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; something(&#39;&#39;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; something([])</span>
<span class="sd">        False</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="n">anything</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">anything</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">anything</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span></div>


<div class="viewcode-block" id="gen_session_id"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.gen_session_id">[docs]</a><span class="k">def</span> <span class="nf">gen_session_id</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates a random alphanumeric string.</span>

<span class="sd">    :arg int length:</span>
<span class="sd">        Optional, ``5`` by default. Specifies the length of the random</span>
<span class="sd">        string.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*str*) -- Random alphanumeric string of the specified length.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">abc</span> <span class="o">=</span> <span class="s1">&#39;0123456789abcdefghijklmnopqrstuvwxyz&#39;</span>

    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">length</span><span class="p">))</span></div>


<span class="c1"># XXX: Are you sure this is the way to compute Simpson&#39;s index?</span>
<div class="viewcode-block" id="simpson_index"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.simpson_index">[docs]</a><span class="k">def</span> <span class="nf">simpson_index</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes Simpson&#39;s index.</span>

<span class="sd">    Given two sets *a* and *b*, returns the Simpson index.</span>

<span class="sd">    :arg set a:</span>
<span class="sd">        Or any iterable type (will be converted to set).</span>
<span class="sd">    :arg set b:</span>
<span class="sd">        Or any iterable type (will be converted to set).</span>

<span class="sd">    :return:</span>
<span class="sd">        (*float*) -- The Simpson index between *a* and *b*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">ab</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ab</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span></div>


<span class="c1"># XXX: Related to comment above, what is this exactly?</span>
<div class="viewcode-block" id="simpson_index_counts"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.simpson_index_counts">[docs]</a><span class="k">def</span> <span class="nf">simpson_index_counts</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :arg a:</span>
<span class="sd">    :arg b:</span>
<span class="sd">    :arg c:</span>

<span class="sd">    :return:</span>
<span class="sd">        (*float*) --</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="sorensen_index"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.sorensen_index">[docs]</a><span class="k">def</span> <span class="nf">sorensen_index</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the Sorensen index.</span>

<span class="sd">    Computes the Sorensen-Dice coefficient between two sets *a* and *b*.</span>

<span class="sd">    :arg set a:</span>
<span class="sd">        Or any iterable type (will be converted to set).</span>
<span class="sd">    :arg set b:</span>
<span class="sd">        Or any iterable type (will be converted to set).</span>

<span class="sd">    :return:</span>
<span class="sd">        (*float*) -- The Sorensen-Dice coefficient between *a* and *b*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">ab</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ab</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span></div>


<div class="viewcode-block" id="jaccard_index"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.jaccard_index">[docs]</a><span class="k">def</span> <span class="nf">jaccard_index</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the Jaccard index.</span>

<span class="sd">    Computes the Jaccard index between two sets *a* and *b*.</span>

<span class="sd">    :arg set a:</span>
<span class="sd">        Or any iterable type (will be converted to set).</span>
<span class="sd">    :arg set b:</span>
<span class="sd">        Or any iterable type (will be converted to set).</span>

<span class="sd">    :return:</span>
<span class="sd">        (*float*) -- The Jaccard index between *a* and *b*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">ab</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ab</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">))</span></div>


<div class="viewcode-block" id="console"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.console">[docs]</a><span class="k">def</span> <span class="nf">console</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prints a message on the terminal.</span>

<span class="sd">    Prints a *message* to the standard output (e.g. terminal) formatted</span>
<span class="sd">    to 80 characters per line plus first-level indentation.</span>

<span class="sd">    :arg str message:</span>
<span class="sd">        The message to be printed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">message</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">80</span><span class="p">))</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></div>


<div class="viewcode-block" id="wcl"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.wcl">[docs]</a><span class="k">def</span> <span class="nf">wcl</span><span class="p">(</span><span class="n">f</span><span class="p">):</span> <span class="c1"># XXX: Not used (another function w/ same name defined in curl.py)</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">toClose</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">is</span> <span class="n">file</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">is</span> <span class="n">file</span> <span class="k">else</span> <span class="nb">open</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="n">toClose</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span></div>


<span class="c1"># XXX: Not very clear to me the purpose of this function.</span>
<div class="viewcode-block" id="get_args"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.get_args">[docs]</a><span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="n">loc_dict</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="nb">set</span><span class="p">([])):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a dictionary of local variables, returns a copy of it without</span>
<span class="sd">    ``&#39;self&#39;``, ``&#39;kwargs&#39;`` (in the scope of a :py:obj:`class`) plus</span>
<span class="sd">    any other specified in the keyword argument *remove*.</span>

<span class="sd">    :arg dict loc_dict:</span>
<span class="sd">        Dictionary containing the local variables (e.g. a call to</span>
<span class="sd">        :py:func:`locals` in a given scope).</span>
<span class="sd">    :arg set remove:</span>
<span class="sd">        Optional, ``set([])`` by default. Can also be a list. Contains</span>
<span class="sd">        the keys of the elements in *loc_dict* that will be removed.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*dict*) -- Copy of *loc_dict* without ``&#39;self&#39;``, ``&#39;kwargs&#39;``</span>
<span class="sd">        and any other element specified in *remove*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">set</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
        <span class="n">remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">remove</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span>

    <span class="n">remove</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="n">remove</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;kwargs&#39;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">loc_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;kwargs&#39;</span> <span class="ow">in</span> <span class="n">loc_dict</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="o">+</span> <span class="n">loc_dict</span><span class="p">[</span><span class="s1">&#39;kwargs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">args</span></div>


<span class="c1"># From http://stackoverflow.com/a/20024348/854988</span>
<div class="viewcode-block" id="rotate"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.rotate">[docs]</a><span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)):</span> <span class="c1"># XXX: Not used? Wrote the docs before checking XD</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotates a point with respect to a center.</span>

<span class="sd">    Rotates a given *point* around a *center* according to the specified</span>
<span class="sd">    *angle* (in degrees) in a two-dimensional space. The rotation is</span>
<span class="sd">    counter-clockwise.</span>

<span class="sd">    :arg tuple point:</span>
<span class="sd">        Or list. Contains the two coordinates of the point to be</span>
<span class="sd">        rotated.</span>
<span class="sd">    :arg float angle:</span>
<span class="sd">        Angle (in degrees) from which the point will be rotated with</span>
<span class="sd">        respect to *center* (counter-clockwise).</span>
<span class="sd">    :arg tuple center:</span>
<span class="sd">        Optional, ``(0.0, 0.0)`` by default. Can also be a list.</span>
<span class="sd">        Determines the two coordinates of the center relative to which</span>
<span class="sd">        the point has to be rotated.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*tuple*) -- Pair of coordinates of the rotated point.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">temp_point</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">temp_point</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
                  <span class="o">-</span> <span class="n">temp_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>
                  <span class="n">temp_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
                  <span class="o">+</span> <span class="n">temp_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
    <span class="n">temp_point</span> <span class="o">=</span> <span class="n">temp_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">temp_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">temp_point</span></div>


<div class="viewcode-block" id="clean_dict"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.clean_dict">[docs]</a><span class="k">def</span> <span class="nf">clean_dict</span><span class="p">(</span><span class="n">dct</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cleans a dictionary of ``None`` values.</span>

<span class="sd">    Removes ``None`` values from  a dictionary *dct* and casts all other</span>
<span class="sd">    values to strings.</span>

<span class="sd">    :arg dict dct:</span>
<span class="sd">        Dictionary to be cleaned from ``None`` values.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*dict*) -- Copy of *dct* without ``None`` value entries and all</span>
<span class="sd">        other values formatted to strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">toDel</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">dct</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">toDel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">dct</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">toDel</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">dct</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">dct</span></div>


<div class="viewcode-block" id="md5"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.md5">[docs]</a><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the sum of MD5 hash of a given string *value*.</span>

<span class="sd">    :arg str value:</span>
<span class="sd">        Or any other type (will be converted to string). Value for which</span>
<span class="sd">        the MD5 sum will be computed. Must follow ASCII encoding.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*str*) -- Hash value resulting from the MD5 sum of the *value*</span>
<span class="sd">        string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>

    <span class="k">except</span><span class="p">:</span> <span class="c1"># XXX: Bad practice to catch all exceptions</span>
        <span class="n">string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span> <span class="c1"># XXX: Same as the try statement!?</span>

    <span class="k">return</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>


<span class="c1"># XXX: Shouldn&#39;t we keep all functions and variables separated</span>
<span class="c1">#      (together among them)?</span>
<span class="n">igraph_graphics_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vertex&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39; color&#39;</span><span class="p">,</span> <span class="s1">&#39;frame_color&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;frame_width&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;label_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;label_color&#39;</span><span class="p">,</span> <span class="s1">&#39;label_size&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;label_angle&#39;</span><span class="p">],</span>
                         <span class="s1">&#39;edge&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;curved&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="s1">&#39;arrow_size&#39;</span><span class="p">,</span>
                                  <span class="s1">&#39;arrow_width&#39;</span><span class="p">]}</span>


<span class="k">def</span> <span class="nf">merge_dicts</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merges dictionaries recursively.</span>

<span class="sd">    If a key exists in both dictionaries, the values will be merged.</span>

<span class="sd">    :arg dict d1:</span>
<span class="sd">        Base dictionary where *d2* will be merged.</span>
<span class="sd">    :arg dict d1:</span>
<span class="sd">        Dictionary to be merged into *d1*.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*dict*) -- Resulting dictionary from the merging.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">k2</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">d2</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">k2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d1</span><span class="p">:</span>
            <span class="n">d1</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v2</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">d1</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge_dicts</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k2</span><span class="p">],</span> <span class="n">v2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">d1</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">set</span><span class="p">:</span>
            <span class="n">d1</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d1</span>


<span class="c1"># XXX: Not 100% clear, correct if I&#39;m mistaken. What do you mean by</span>
<span class="c1">#      simple heuristic?</span>
<span class="k">def</span> <span class="nf">dict_set_path</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a dictionary of dictionaries *d* looks up the keys according</span>
<span class="sd">    to *path*, creates new subdicts and keys if those do not exist yet,</span>
<span class="sd">    and sets/merges the leaf element according to simple heuristic.</span>

<span class="sd">    :arg dict d:</span>
<span class="sd">        Dictionary of dictionaries for which the path is to be set.</span>
<span class="sd">    :arg list path:</span>
<span class="sd">        Or tuple, contains the path of keys being the first element a</span>
<span class="sd">        key of *d* (if doesn&#39;t exist will be created), and the</span>
<span class="sd">        subsequent of the inner dictionaries. The last element is the</span>
<span class="sd">        value that will be set/merged on the specified path.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*dict*) -- Copy of *d* including the specified *path*.</span>

<span class="sd">    **Example:**</span>
<span class="sd">        &gt;&gt;&gt; dict_set_path(dict(), [&#39;a&#39;, &#39;b&#39;, 1])</span>
<span class="sd">        {&#39;a&#39;: {&#39;b&#39;: 1}}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">subd</span> <span class="o">=</span> <span class="n">d</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">subd</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">subd</span><span class="p">:</span>
                <span class="n">subd</span> <span class="o">=</span> <span class="n">subd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">subd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">subd</span> <span class="o">=</span> <span class="n">subd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>

    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subd</span><span class="p">:</span>
        <span class="n">subd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">subd</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">subd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">subd</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">subd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">subd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">subd</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">set</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">set</span><span class="p">:</span>
            <span class="n">subd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">subd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d</span>


<div class="viewcode-block" id="dict_diff"><a class="viewcode-back" href="../../../reference.html#pypath.share.common.dict_diff">[docs]</a><span class="k">def</span> <span class="nf">dict_diff</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compares two dictionaries.</span>

<span class="sd">    Compares two given dictionaries *d1* and *d2* whose values are sets</span>
<span class="sd">    or dictionaries (in such case the function is called recursively).</span>
<span class="sd">    **NOTE:** The comparison is only performed on the values of the</span>
<span class="sd">    keys that are common in *d1* and *d2* (see example below).</span>

<span class="sd">    :arg dict d1:</span>
<span class="sd">        First dictionary of the comparison.</span>
<span class="sd">    :arg dict d2:</span>
<span class="sd">        Second dictionary of the comparison.</span>

<span class="sd">    :return:</span>
<span class="sd">        * (*dict*) -- Unique elements of *d1* when compared to *d2*.</span>
<span class="sd">        * (*dict*) -- Unique elements of *d2* when compared to *d1*.</span>

<span class="sd">    **Examples:**</span>
<span class="sd">        &gt;&gt;&gt; d1 = {&#39;a&#39;: {1}, &#39;b&#39;: {2}, &#39;c&#39;: {3}} # &#39;c&#39; is unique to d1</span>
<span class="sd">        &gt;&gt;&gt; d2 = {&#39;a&#39;: {1}, &#39;b&#39;: {3}}</span>
<span class="sd">        &gt;&gt;&gt; dict_diff(d1, d2)</span>
<span class="sd">        ({&#39;a&#39;: set([]), &#39;b&#39;: set([2])}, {&#39;a&#39;: set([2]), &#39;b&#39;: set([3])})</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ldiff</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">rdiff</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">ldiff</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">rdiff</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_diff</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">set</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">set</span><span class="p">:</span>
            <span class="n">ldiff</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">rdiff</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ldiff</span><span class="p">,</span> <span class="n">rdiff</span></div>


<span class="k">def</span> <span class="nf">dict_sym_diff</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span> <span class="c1"># XXX: Not used</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">diff</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_sym_diff</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">set</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">set</span><span class="p">:</span>
            <span class="n">diff</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">^</span> <span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">diff</span>


<span class="k">def</span> <span class="nf">swap_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Swaps a dictionary.</span>

<span class="sd">    Interchanges the keys and values of a dictionary. If the values are</span>
<span class="sd">    lists (or any iterable type) and/or not unique, each unique element</span>
<span class="sd">    will be a key and values sets of the original keys of *d* (see</span>
<span class="sd">    example below).</span>

<span class="sd">    :arg dict d:</span>
<span class="sd">        Original dictionary to be swapped.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*dict*) -- The swapped dictionary.</span>

<span class="sd">    **Examples:**</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;a&#39;: 1, &#39;b&#39;: 2}</span>
<span class="sd">        &gt;&gt;&gt; swap_dict(d)</span>
<span class="sd">        {1: &#39;a&#39;, 2: &#39;b&#39;}</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;a&#39;: 1, &#39;b&#39;: 1, &#39;c&#39;: 2}</span>
<span class="sd">        &gt;&gt;&gt; swap_dict(d)</span>
<span class="sd">        {1: set([&#39;a&#39;, &#39;b&#39;]), 2: set([&#39;c&#39;])}</span>
<span class="sd">        d = {&#39;a&#39;: [1, 2, 3], &#39;b&#39;: [2, 3]}</span>
<span class="sd">        &gt;&gt;&gt; swap_dict(d)</span>
<span class="sd">        {1: set([&#39;a&#39;]), 2: set([&#39;a&#39;, &#39;b&#39;]), 3: set([&#39;a&#39;, &#39;b&#39;])}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_d</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="ow">in</span> <span class="n">simple_types</span> <span class="k">else</span> <span class="n">vals</span>
        
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_d</span><span class="p">:</span>
                <span class="n">_d</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            
            <span class="n">_d</span><span class="p">[</span><span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_d</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        
        <span class="n">_d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">_d</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">_d</span>


<span class="k">def</span> <span class="nf">swap_dict_simple</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps a dictionary.</span>

<span class="sd">    Interchanges the keys and values of a dictionary. Assumes the values</span>
<span class="sd">    are unique and hashable, otherwise overwrites duplicates or raises</span>
<span class="sd">    error.</span>

<span class="sd">    :arg dict d:</span>
<span class="sd">        Original dictionary to be swapped.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*dict*) -- The swapped dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>


<span class="c1"># XXX: Not sure what this joins exactly... I tried:</span>
<span class="c1">#      &gt;&gt;&gt; a = {&#39;a&#39;: [1], &#39;b&#39;: [2]}</span>
<span class="c1">#      &gt;&gt;&gt; b = {&#39;a&#39;: [2], &#39;b&#39;: [4]}</span>
<span class="c1">#      &gt;&gt;&gt; join_dicts(a, b)</span>
<span class="c1">#      and got an empty dictionary (?)</span>

<span class="k">def</span> <span class="nf">join_dicts</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">_from</span><span class="o">=</span><span class="s1">&#39;keys&#39;</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s1">&#39;values&#39;</span><span class="p">):</span> <span class="c1"># TODO</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Joins a pair of dictionaries.</span>

<span class="sd">    :arg dict d1:</span>
<span class="sd">        Dictionary to be merged with *d2*</span>
<span class="sd">    :arg dict d2:</span>
<span class="sd">        Dictionary to be merged with *d1*</span>
<span class="sd">    :arg str _from:</span>
<span class="sd">        Optional, ``&#39;keys&#39;`` by default.</span>
<span class="sd">    :arg str to:</span>
<span class="sd">        Optional, ``&#39;values&#39;`` by default.</span>

<span class="sd">    :return:</span>
<span class="sd">        (*dict*) -- .</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;keys&#39;</span><span class="p">:</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">swap_dict</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">key1</span><span class="p">,</span> <span class="n">val1</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">d1</span><span class="p">):</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">([</span><span class="n">key1</span><span class="p">]</span> <span class="k">if</span> <span class="n">_from</span> <span class="o">==</span> <span class="s1">&#39;keys&#39;</span>
                          <span class="k">else</span> <span class="p">[</span><span class="n">val1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">simple_types</span>
                                      <span class="k">else</span> <span class="n">val1</span><span class="p">)</span>
        <span class="n">meds</span> <span class="o">=</span> <span class="p">([</span><span class="n">key1</span><span class="p">]</span> <span class="k">if</span> <span class="n">_from</span> <span class="o">==</span> <span class="s1">&#39;values&#39;</span>
                       <span class="k">else</span> <span class="p">[</span><span class="n">val1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">simple_types</span>
                                   <span class="k">else</span> <span class="n">val1</span><span class="p">)</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>

        <span class="k">for</span> <span class="n">med</span> <span class="ow">in</span> <span class="n">meds</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">med</span> <span class="ow">in</span> <span class="n">d2</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">med</span><span class="p">])</span>

                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">med</span><span class="p">])</span> <span class="ow">in</span> <span class="n">simple_types</span><span class="p">:</span>
                    <span class="n">targets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">med</span><span class="p">])</span>

                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">med</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="n">targets</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">med</span><span class="p">]))</span>

                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">med</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">set</span><span class="p">:</span>
                    <span class="n">targets</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">med</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">d2</span><span class="p">[</span><span class="n">med</span><span class="p">]</span><span class="o">.</span><span class="fm">__hash__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">targets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">med</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">targets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
                    <span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">med</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">result</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">set</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>

                <span class="n">result</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="n">psite_mod_types</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;phosphorylation&#39;</span><span class="p">),</span>
                   <span class="p">(</span><span class="s1">&#39;ac&#39;</span><span class="p">,</span> <span class="s1">&#39;acetylation&#39;</span><span class="p">),</span>
                   <span class="p">(</span><span class="s1">&#39;ga&#39;</span><span class="p">,</span> <span class="s1">&#39;galactosylation&#39;</span><span class="p">),</span>
                   <span class="p">(</span><span class="s1">&#39;gl&#39;</span><span class="p">,</span> <span class="s1">&#39;glycosylation&#39;</span><span class="p">),</span>
                   <span class="p">(</span><span class="s1">&#39;sm&#39;</span><span class="p">,</span> <span class="s1">&#39;sumoylation&#39;</span><span class="p">),</span>
                   <span class="p">(</span><span class="s1">&#39;ub&#39;</span><span class="p">,</span> <span class="s1">&#39;ubiquitination&#39;</span><span class="p">),</span>
                   <span class="p">(</span><span class="s1">&#39;me&#39;</span><span class="p">,</span> <span class="s1">&#39;methylation&#39;</span><span class="p">)]</span>

<span class="n">psite_mod_types2</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;phosphorylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;ac&#39;</span><span class="p">,</span> <span class="s1">&#39;acetylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;ga&#39;</span><span class="p">,</span> <span class="s1">&#39;galactosylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;gl&#39;</span><span class="p">,</span> <span class="s1">&#39;glycosylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;ub&#39;</span><span class="p">,</span> <span class="s1">&#39;ubiquitination&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;me&#39;</span><span class="p">,</span> <span class="s1">&#39;methylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;sm&#39;</span><span class="p">,</span> <span class="s1">&#39;sumoylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;sc&#39;</span><span class="p">,</span> <span class="s1">&#39;succinylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;m1&#39;</span><span class="p">,</span> <span class="s1">&#39;mono-methylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;m2&#39;</span><span class="p">,</span> <span class="s1">&#39;di-methylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;m3&#39;</span><span class="p">,</span> <span class="s1">&#39;tri-methylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;ad&#39;</span><span class="p">,</span> <span class="s1">&#39;adenylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;pa&#39;</span><span class="p">,</span> <span class="s1">&#39;palmitoylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;ne&#39;</span><span class="p">,</span> <span class="s1">&#39;neddylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;sn&#39;</span><span class="p">,</span> <span class="s1">&#39;nitrosylation&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;ca&#39;</span><span class="p">,</span> <span class="s1">&#39;caspase-cleavage&#39;</span><span class="p">)]</span>


<span class="n">pmod_bel</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">(</span><span class="s1">&#39;Ac&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;acetylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;ADPRib&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;ADP-ribosylation&#39;</span><span class="p">,</span> <span class="s1">&#39;ADP-rybosylation&#39;</span><span class="p">,</span> <span class="s1">&#39;adenosine diphosphoribosyl&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Farn&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;farnesylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Gerger&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;geranylgeranylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Glyco&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;glycosylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Hy&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;hydroxylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;ISG&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;ISGylation&#39;</span><span class="p">,</span> <span class="s1">&#39;ISG15-protein conjugation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Me&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;methylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Me1&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;monomethylation&#39;</span><span class="p">,</span> <span class="s1">&#39;mono-methylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Me2&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;dimethylation&#39;</span><span class="p">,</span> <span class="s1">&#39;di-methylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Me3&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;trimethylation&#39;</span><span class="p">,</span> <span class="s1">&#39;tri-methylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Myr&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;myristoylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Nedd&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;neddylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;NGlyco&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;N-linked glycosylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;OGlyco&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;O-linked glycosylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Palm&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;palmitoylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Ph&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;phosphorylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Sumo&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;sumoylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;Ub&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;ubiquitination&#39;</span><span class="p">,</span> <span class="s1">&#39;ubiquitinylation&#39;</span><span class="p">,</span> <span class="s1">&#39;ubiquitylation&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;UbK48&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Lysine 48-linked polyubiquitination&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;UbK63&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Lysine 63-linked polyubiquitination&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;UbMono&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;monoubiquitination&#39;</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s1">&#39;UbPoly&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;polyubiquitination&#39;</span><span class="p">,)),</span>
<span class="p">)</span>

<span class="n">pmod_bel_to_other</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">pmod_bel</span><span class="p">)</span>
<span class="n">pmod_other_to_bel</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="p">(</span><span class="n">other_name</span><span class="p">,</span> <span class="n">bel_name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bel_name</span><span class="p">,</span> <span class="n">other_names</span> <span class="ow">in</span> <span class="n">pmod_bel</span>
    <span class="k">for</span> <span class="n">other_name</span> <span class="ow">in</span> <span class="n">other_names</span>
<span class="p">)</span>


<span class="n">amino_acids</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">(</span><span class="s1">&#39;alanine&#39;</span><span class="p">,</span> <span class="s1">&#39;Ala&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;arginine&#39;</span><span class="p">,</span> <span class="s1">&#39;Arg&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;asparagine&#39;</span><span class="p">,</span> <span class="s1">&#39;Asn&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;aspartic acid&#39;</span><span class="p">,</span> <span class="s1">&#39;Asp&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;asparagine or aspartic acid&#39;</span><span class="p">,</span> <span class="s1">&#39;Asx&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;cysteine&#39;</span><span class="p">,</span> <span class="s1">&#39;Cys&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;glutamic acid&#39;</span><span class="p">,</span> <span class="s1">&#39;Glu&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;glutamine&#39;</span><span class="p">,</span> <span class="s1">&#39;Gln&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;glutamine or glutamic acid&#39;</span><span class="p">,</span> <span class="s1">&#39;Glx&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;glycine&#39;</span><span class="p">,</span> <span class="s1">&#39;Gly&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;histidine&#39;</span><span class="p">,</span> <span class="s1">&#39;His&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;isoleucine&#39;</span><span class="p">,</span> <span class="s1">&#39;Ile&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;leucine&#39;</span><span class="p">,</span> <span class="s1">&#39;Leu&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;lysine&#39;</span><span class="p">,</span> <span class="s1">&#39;Lys&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;methionine&#39;</span><span class="p">,</span> <span class="s1">&#39;Met&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;phenylalanine&#39;</span><span class="p">,</span> <span class="s1">&#39;Phe&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;proline&#39;</span><span class="p">,</span> <span class="s1">&#39;Pro&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;serine&#39;</span><span class="p">,</span> <span class="s1">&#39;Ser&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;threonine&#39;</span><span class="p">,</span> <span class="s1">&#39;Thr&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;tryptophan&#39;</span><span class="p">,</span> <span class="s1">&#39;Trp&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;tyrosine&#39;</span><span class="p">,</span> <span class="s1">&#39;Tyr&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;valine&#39;</span><span class="p">,</span> <span class="s1">&#39;Val&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">),</span>
<span class="p">)</span>


<span class="n">aminoa_3_to_1_letter</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="p">(</span><span class="n">code3</span><span class="p">,</span> <span class="n">code1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">code3</span><span class="p">,</span> <span class="n">code1</span> <span class="ow">in</span> <span class="n">amino_acids</span>
<span class="p">)</span>


<span class="n">aminoa_1_to_3_letter</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="p">(</span><span class="n">code1</span><span class="p">,</span> <span class="n">code3</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">code3</span><span class="p">,</span> <span class="n">code1</span> <span class="ow">in</span> <span class="n">amino_acids</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">silent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="c1"># XXX: Never used</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aux</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">devnull</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>

        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux</span>


<span class="k">def</span> <span class="nf">paginate</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Yields sections of length ``size`` from list ``lst``.</span>
<span class="sd">    The last section might be shorter than ``size``.</span>
<span class="sd">    Following https://stackoverflow.com/a/3744502/854988.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">//</span> <span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        
        <span class="k">yield</span> <span class="n">lst</span><span class="p">[</span><span class="n">size</span> <span class="o">*</span> <span class="n">i</span><span class="p">:</span><span class="n">size</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">shared_unique</span><span class="p">(</span><span class="n">by_group</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;shared&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a *dict* of *set*s ``by_group`` and a particular key ``group``</span>
<span class="sd">    returns a *set* of all elements in the *set* belonging to the</span>
<span class="sd">    key ``group`` which either does or does not occure in any of the sets</span>
<span class="sd">    assigned to the other keys, depending on the operator ``op``.</span>
<span class="sd">    This method can be used among other things to find the shared and</span>
<span class="sd">    unique entities across resources.</span>
<span class="sd">    </span>
<span class="sd">    :arg str op:</span>
<span class="sd">        Either `shared` or `unique`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">by_group</span><span class="p">:</span>
        
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s1">&#39;Group `</span><span class="si">%s</span><span class="s1">` missing from the dict of groups!&#39;</span> <span class="o">%</span> <span class="n">group</span>
        <span class="p">)</span>
    
    <span class="n">_op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span> <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;unique&#39;</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">and_</span>
    
    <span class="k">return</span> <span class="n">_op</span><span class="p">(</span>
        <span class="n">by_group</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="k">if</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">by_group</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(),</span>
        <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">(</span>
            <span class="n">elements</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">elements</span>
            <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">by_group</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="n">group</span>
        <span class="p">),</span> <span class="nb">set</span><span class="p">())</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">shared_elements</span><span class="p">(</span><span class="n">by_group</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a *dict* of *set*s ``by_group`` and a particular key ``group``</span>
<span class="sd">    returns a *set* of all elements in the *set* belonging to the</span>
<span class="sd">    key ``group`` which occure in any of the sets assigned to the other keys.</span>
<span class="sd">    This method can be used among other things to find the shared entities</span>
<span class="sd">    across resources.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="n">shared_unique</span><span class="p">(</span>
        <span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="p">,</span>
        <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;shared&#39;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">unique_elements</span><span class="p">(</span><span class="n">by_group</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a *dict* of *set*s ``by_group`` and a particular key ``group``</span>
<span class="sd">    returns a *set* of all elements in the *set* belonging to the</span>
<span class="sd">    key ``group`` which don&#39;t occure in any of the sets assigned to the</span>
<span class="sd">    other keys. This method can be used among other things to find the</span>
<span class="sd">    unique entities across resources.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="n">shared_unique</span><span class="p">(</span>
        <span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="p">,</span>
        <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;unique&#39;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">n_shared_elements</span><span class="p">(</span><span class="n">by_group</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a *dict* of *set*s ``by_group`` and a particular key ``group``</span>
<span class="sd">    returns the number of all elements in the *set* belonging to the</span>
<span class="sd">    key ``group`` which occure in any of the other sets.</span>
<span class="sd">    This method can be used among other things to count the shared entities</span>
<span class="sd">    across resources.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_elements</span><span class="p">(</span><span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span> <span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">n_unique_elements</span><span class="p">(</span><span class="n">by_group</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a *dict* of *set*s ``by_group`` and a particular key ``group``</span>
<span class="sd">    returns the number of all elements in the *set* belonging to the</span>
<span class="sd">    key ``group`` which don&#39;t occure in any of the other sets.</span>
<span class="sd">    This method can be used among other things to count the unique entities</span>
<span class="sd">    across resources.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_elements</span><span class="p">(</span><span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span> <span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">shared_unique_foreach</span><span class="p">(</span><span class="n">by_group</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;shared&#39;</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a *dict* of *set*s ``by_group`` returns a *dict* of *set*s with</span>
<span class="sd">    either shared or unique elements across all *set*s, depending on</span>
<span class="sd">    the operation ``op``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">method</span> <span class="o">=</span> <span class="nb">len</span> <span class="k">if</span> <span class="n">counts</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
    
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">label</span><span class="p">,</span>
            <span class="n">method</span><span class="p">(</span>
                <span class="n">shared_unique</span><span class="p">(</span><span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span> <span class="n">group</span> <span class="o">=</span> <span class="n">label</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">)</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">by_group</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">n_shared_unique_foreach</span><span class="p">(</span><span class="n">by_group</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;shared&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a *dict* of *set*s ``by_group`` returns a *dict* of numbers with</span>
<span class="sd">    the counts of either the shared or unique elements across all *set*s,</span>
<span class="sd">    depending on the operation ``op``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="n">shared_unique_foreach</span><span class="p">(</span>
        <span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span>
        <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;shared&#39;</span><span class="p">,</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">shared_foreach</span><span class="p">(</span><span class="n">by_group</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">shared_unique_foreach</span><span class="p">(</span><span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;shared&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unique_foreach</span><span class="p">(</span><span class="n">by_group</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">shared_unique_foreach</span><span class="p">(</span><span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;unique&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">n_shared_foreach</span><span class="p">(</span><span class="n">by_group</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">n_shared_unique_foreach</span><span class="p">(</span><span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;shared&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">n_unique_foreach</span><span class="p">(</span><span class="n">by_group</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">n_shared_unique_foreach</span><span class="p">(</span><span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;unique&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">dict_union</span><span class="p">(</span><span class="n">dict_of_sets</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a *dict* of *set*s returns the union of the values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">dict_of_sets</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">dict_of_sets</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">dict_counts</span><span class="p">(</span><span class="n">dict_of_sets</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a *dict* of *set*s or other values with ``__len__`` returns a</span>
<span class="sd">    *dict* of numbers with the length of each value in the original *dict*.</span>
<span class="sd">    </span>
<span class="sd">    This function is recursively works on dicts of dicts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">key</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="n">dict_counts</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">dict_of_sets</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">dict_expand_keys</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">front</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From a *dict* with *tuple* keys builds a dict of dicts.</span>
<span class="sd">    </span>
<span class="sd">    :arg dict dct:</span>
<span class="sd">        A *dict* with tuple keys (if keys are not tuples ``dct`` will be</span>
<span class="sd">        returned unchanged).</span>
<span class="sd">    :arg int depth:</span>
<span class="sd">        Expand the keys up to this depth. If 0 *dct* will be returned</span>
<span class="sd">        unchanged, if 1 dict of dicts, if 2 dict of dict of dicts will be</span>
<span class="sd">        returned, and so on.</span>
<span class="sd">    :arg bool front:</span>
<span class="sd">        If ``True`` the tuple keys will be chopped from the front, otherwise</span>
<span class="sd">        from their ends.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        
        <span class="k">return</span> <span class="n">dct</span>
    
    <span class="n">new</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">dct</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            
            <span class="n">new</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            
            <span class="n">new</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
        
        <span class="k">else</span><span class="p">:</span>
            
            <span class="n">outer_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">front</span> <span class="k">else</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">inner_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">front</span> <span class="k">else</span> <span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inner_key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                
                <span class="n">inner_key</span> <span class="o">=</span> <span class="n">inner_key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="n">sub_dct</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">outer_key</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">sub_dct</span><span class="p">[</span><span class="n">inner_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    
    <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        
        <span class="n">new</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">key</span><span class="p">,</span>
                    <span class="n">dict_expand_keys</span><span class="p">(</span><span class="n">sub_dct</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">sub_dct</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="p">)</span>
                <span class="k">if</span> <span class="n">front</span> <span class="k">else</span>
            <span class="n">dict_expand_keys</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">front</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span> <span class="nf">dict_collapse_keys</span><span class="p">(</span>
        <span class="n">dct</span><span class="p">,</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">front</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">expand_tuple_keys</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From a dict of dicts builds a dict with tuple keys.</span>
<span class="sd">    </span>
<span class="sd">    :arg dict dct:</span>
<span class="sd">        A dict of dicts (if values are not dicts it will be returned</span>
<span class="sd">        unchanged).</span>
<span class="sd">    :arg int depth:</span>
<span class="sd">        Collapse the keys up to this depth. If 0 *dct* will be returned</span>
<span class="sd">        unchanged, if 1 tuple keys will have 2 elements, if 2 then</span>
<span class="sd">        2 elements, and so on.</span>
<span class="sd">    :arg bool front:</span>
<span class="sd">        If ``True`` the tuple keys will be collapsed first from the</span>
<span class="sd">        outermost dict going towards the innermost one until depth allows.</span>
<span class="sd">        Otherwise the method will start from the innermost ones.</span>
<span class="sd">    :arg bool expand_tuple_keys:</span>
<span class="sd">        If ``True`` the tuple keys of inner dicts will be concatenated with</span>
<span class="sd">        the outer key tuples. If ``False`` the inner tuple keys will be added</span>
<span class="sd">        as an element of the tuple key i.e. tuple in tuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">front</span><span class="p">:</span>
        
        <span class="c1"># this is difficult to implement because we have no idea about</span>
        <span class="c1"># the depth; this version ensures an even key length for the</span>
        <span class="c1"># tuple keys; another alterntive would be to iterate recursively</span>
        <span class="c1"># over the dictionary tree</span>
        <span class="n">dct</span> <span class="o">=</span> <span class="n">dict_collapse_keys</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">9999999</span><span class="p">)</span>
        <span class="n">maxdepth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dct</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)),</span>
            <span class="n">default</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dict_expand_keys</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">maxdepth</span> <span class="o">-</span> <span class="n">depth</span><span class="p">,</span> <span class="n">front</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dct</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        
        <span class="k">return</span> <span class="n">dct</span>
    
    <span class="n">new</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">dct</span><span class="p">):</span>
        
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            
            <span class="k">for</span> <span class="n">key1</span><span class="p">,</span> <span class="n">val1</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
                
                <span class="n">_key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="p">(</span>
                    <span class="n">key1</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="nb">isinstance</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="n">expand_tuple_keys</span>
                        <span class="p">)</span> <span class="k">else</span>
                    <span class="p">(</span><span class="n">key1</span><span class="p">,)</span>
                <span class="p">)</span>
                <span class="n">new</span><span class="p">[</span><span class="n">_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val1</span>
            
        <span class="k">else</span><span class="p">:</span>
            
            <span class="n">new</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    
    <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        
        <span class="n">new</span> <span class="o">=</span> <span class="n">dict_collapse_keys</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span> <span class="nf">shared_unique_total</span><span class="p">(</span><span class="n">by_group</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;shared&#39;</span><span class="p">):</span>
    
    <span class="n">counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">by_group</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">_op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span> <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;unique&#39;</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span>
    
    <span class="k">return</span> <span class="p">{</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="k">if</span> <span class="n">_op</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>


<span class="k">def</span> <span class="nf">shared_total</span><span class="p">(</span><span class="n">by_group</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">shared_unique_total</span><span class="p">(</span><span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;shared&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unique_total</span><span class="p">(</span><span class="n">by_group</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">shared_unique_total</span><span class="p">(</span><span class="n">by_group</span> <span class="o">=</span> <span class="n">by_group</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;unique&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">n_shared_total</span><span class="p">(</span><span class="n">by_group</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_total</span><span class="p">(</span><span class="n">by_group</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">n_unique_total</span><span class="p">(</span><span class="n">by_group</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_total</span><span class="p">(</span><span class="n">by_group</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">dict_subtotals</span><span class="p">(</span><span class="n">dct</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a dict of dicts of sets returns a dict with keys of the outer dict</span>
<span class="sd">    and values the union of the sets in each of the inner dicts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">key</span><span class="p">,</span>
            <span class="n">dict_union</span><span class="p">(</span><span class="n">sub_dct</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">sub_dct</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">dct</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">dict_percent</span><span class="p">(</span><span class="n">dict_of_counts</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a *dict* of counts and a total count creates a *dict* of percentages.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="n">total</span> <span class="k">if</span> <span class="n">total</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">dict_of_counts</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">dict_set_percent</span><span class="p">(</span><span class="n">dict_of_sets</span><span class="p">):</span>
    
    <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_union</span><span class="p">(</span><span class="n">dict_of_sets</span><span class="p">))</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">dict_counts</span><span class="p">(</span><span class="n">dict_of_sets</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">dict_percent</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">df_memory_usage</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">deep</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the memory usage of a ``pandas.DataFrame`` as a string.</span>
<span class="sd">    Modified from ``pandas.DataFrame.info``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">counts</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_dtype_counts</span><span class="p">()</span>
    
    <span class="n">size_qualifier</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;+&#39;</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="s1">&#39;object&#39;</span> <span class="ow">in</span> <span class="n">counts</span> <span class="ow">or</span>
                <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_is_memory_usage_qualified</span><span class="p">()</span>
            <span class="p">)</span> <span class="k">else</span>
        <span class="s1">&#39;&#39;</span>
    <span class="p">)</span>
    
    <span class="n">mem_usage</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">deep</span> <span class="o">=</span> <span class="n">deep</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bytes&#39;</span><span class="p">,</span> <span class="s1">&#39;KB&#39;</span><span class="p">,</span> <span class="s1">&#39;MB&#39;</span><span class="p">,</span> <span class="s1">&#39;GB&#39;</span><span class="p">,</span> <span class="s1">&#39;TB&#39;</span><span class="p">]:</span>
        
        <span class="k">if</span> <span class="n">mem_usage</span> <span class="o">&lt;</span> <span class="mf">1024.0</span><span class="p">:</span>
            
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%3.1f%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mem_usage</span><span class="p">,</span> <span class="n">size_qualifier</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        
        <span class="n">mem_usage</span> <span class="o">/=</span> <span class="mf">1024.0</span>
    
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%3.1f%s</span><span class="s1"> PB&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mem_usage</span><span class="p">,</span> <span class="n">size_qualifier</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sum_dicts</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For dicts of numbers returns a dict with the sum of the numbers from</span>
<span class="sd">    all dicts for all keys.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">args</span>
    <span class="p">]</span>
    
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">key</span><span class="p">,</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)))</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">combine_attrs</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">num_method</span> <span class="o">=</span> <span class="nb">max</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combines multiple attributes into one. This method attempts</span>
<span class="sd">    to find out which is the best way to combine attributes.</span>

<span class="sd">        * If there is only one value or one of them is None, then</span>
<span class="sd">          returns the one available.</span>
<span class="sd">        * Lists: concatenates unique values of lists.</span>
<span class="sd">        * Numbers: returns the greater by default or calls</span>
<span class="sd">          *num_method* if given.</span>
<span class="sd">        * Sets: returns the union.</span>
<span class="sd">        * Dictionaries: calls :py:func:`pypath.common.merge_dicts`.</span>
<span class="sd">        * Direction: calls their special</span>
<span class="sd">          :py:meth:`pypath.main.Direction.merge` method.</span>

<span class="sd">    Works on more than 2 attributes recursively.</span>

<span class="sd">    :arg list attrs:</span>
<span class="sd">        List of one or more attribute values.</span>
<span class="sd">    :arg function num_method:</span>
<span class="sd">        Optional, ``max`` by default. Method to merge numeric attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_or_set</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">):</span>

        <span class="k">if</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">two</span><span class="p">,</span> <span class="nb">set</span><span class="p">))</span>
            <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">two</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="nb">set</span><span class="p">))):</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">one</span><span class="p">),</span> <span class="nb">set</span><span class="p">(</span><span class="n">two</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">one</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">two</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span>


    <span class="c1"># recursion:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">combine_attrs</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">num_method</span> <span class="o">=</span> <span class="n">num_method</span><span class="p">)]</span>

    <span class="c1"># quick and simple cases:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># merge numeric values</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">numeric_types</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">in</span> <span class="n">numeric_types</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num_method</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
    
    <span class="n">attrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
    
    <span class="c1"># in case one is list other is set</span>
    <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_or_set</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># merge lists:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># lists of hashable elements only:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># if contain non-hashable elements:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># merge sets:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">set</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">add_to_set</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">add_to_set</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># merge dicts:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">merge_dicts</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># 2 different strings: return a set with both of them</span>
    <span class="k">if</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unicode</span><span class="p">))</span>
        <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unicode</span><span class="p">))):</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="c1"># one attr is list, the other is simple value:</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">in</span> <span class="n">simple_types</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">numeric_types</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">add_to_list</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">simple_types</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">numeric_types</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">add_to_list</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># in case the objects have `__add__()` method:</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__add__&#39;</span><span class="p">):</span>
        
        <span class="k">return</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_add_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">signature</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    
    <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">method_name</span>
    
    <span class="k">if</span> <span class="n">signature</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inspect</span><span class="p">,</span> <span class="s1">&#39;Signature&#39;</span><span class="p">):</span> <span class="c1"># Py2</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Signature</span><span class="p">):</span>
            
            <span class="n">signature</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Signature</span><span class="p">([</span>
                <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">kind</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span>
                    <span class="n">default</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span>
                        <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">signature</span>
            <span class="p">])</span>
        
        <span class="n">method</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">signature</span>
    
    <span class="k">if</span> <span class="n">doc</span><span class="p">:</span>
        
        <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc</span>
    
    <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sets_to_sorted_lists</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">sets_to_sorted_list</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="p">)</span>
        
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        
        <span class="k">return</span> <span class="n">obj</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Dénes Türei, Nicolàs Palacio, Olga Ivanova. 
European Molecular Biology Laboratory, Heidelberg Germany
European Bioinformatics Institute, Hinxton UK
University Hospital RWTH, Aachen Germany
University Hospital Heidelberg Germany

    </p>
  </div>
    
    
      Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>